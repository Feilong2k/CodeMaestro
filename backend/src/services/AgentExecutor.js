const TaskQueueService = require('./TaskQueueService');
const registry = require('../tools/registry');
const DeepseekClient = require('../llm/DeepseekClient');

/**
 * Simple XML parser for extracting tool calls from LLM output.
 * This is a temporary implementation until XmlOutputParser (5-4) is ready.
 */
class SimpleXmlParser {
  /**
   * Extract tool calls from text containing XML tags.
   * @param {string} text - The text to parse
   * @returns {Array<Object>} Array of tool call objects
   */
  extractToolCalls(text) {
    const toolCalls = [];
    const toolRegex = /<tool\s+([^>]+)>(.*?)<\/tool>/gs;
    let match;
    while ((match = toolRegex.exec(text)) !== null) {
      const attrs = match[1];
      const content = match[2];
      const toolCall = {};

      // Parse attributes like name="FileSystemTool" action="write"
      const attrRegex = /(\w+)="([^"]+)"/g;
      let attrMatch;
      while ((attrMatch = attrRegex.exec(attrs)) !== null) {
        toolCall[attrMatch[1]] = attrMatch[2];
      }

      // Parse inner elements like <path>test.js</path>
      const innerRegex = /<(\w+)>([^<]*)<\/\1>/g;
      let innerMatch;
      while ((innerMatch = innerRegex.exec(content)) !== null) {
        toolCall[innerMatch[1]] = innerMatch[2];
      }

      toolCalls.push(toolCall);
    }
    return toolCalls;
  }
}

/**
 * AgentExecutor orchestrates the execution of agent tasks.
 * It loops through tool calls generated by an LLM until completion or step budget exhaustion.
 */
class AgentExecutor {
  constructor(config = {}) {
    this.maxSteps = config.maxSteps || 20;
    this.xmlParser = new SimpleXmlParser();
  }

  /**
   * Execute a task by its ID.
   * @param {number} taskId - The task ID (currently unused in dequeue, but kept for future)
   */
  async executeTask(taskId) {
    // Dequeue the task
    const task = await TaskQueueService.dequeue('agent-executor');
    if (!task) {
      throw new Error(`Task ${taskId} not found or already taken`);
    }

    const { id, type, payload } = task;
    let context = { ...payload, steps: [] };
    let stepCount = 0;

    try {
      // Get tools allowed for this agent role
      const tools = registry.getToolsForRole(type);

      // Main execution loop
      while (stepCount < this.maxSteps) {
        stepCount++;

        // Build prompt (simplified for now)
        const prompt = this.buildPrompt(context, tools);

        // Call LLM
        let llmResponse;
        try {
          llmResponse = await DeepseekClient.chatCompletion(prompt);
        } catch (error) {
          // Network error: retry up to 3 times for the same step?
          // For simplicity, we'll just fail the task after one network error (as per test).
          // The test expects a failure after network error.
          throw new Error(`LLM call failed: ${error.message}`);
        }

        const toolCalls = this.xmlParser.extractToolCalls(llmResponse.content);

        // If no tool calls, assume task is complete
        if (toolCalls.length === 0) {
          break;
        }

        // Execute each tool call
        const stepResults = [];
        for (const toolCall of toolCalls) {
          const toolName = toolCall.name;
          const tool = tools[toolName];
          if (!tool) {
            throw new Error(`Tool ${toolName} not allowed for role ${type}`);
          }

          // Execute tool with parameters (excluding 'name' and 'action' which are metadata)
          const { name, action, ...params } = toolCall;
          const result = await tool.execute(params);
          stepResults.push({ tool: toolName, action, params, result });
        }

        // Update context with results
        context.steps.push({
          step: stepCount,
          toolCalls: stepResults,
        });

        // If the tool call was a "NoOpTool" (as in the infinite loop test), we just continue.
        // The test expects the loop to stop after maxSteps.
      }

      // Check why we exited the loop
      if (stepCount >= this.maxSteps) {
        throw new Error(`Step budget exceeded (max ${this.maxSteps} steps)`);
      }

      // Task completed successfully
      await TaskQueueService.complete(id, { context, completed: true });
    } catch (error) {
      // Mark task as failed
      await TaskQueueService.fail(id, error.message);
      // Do not re-throw the error - the task has been marked as failed
    }
  }

  /**
   * Build a prompt for the LLM based on context and available tools.
   * @param {Object} context - The current execution context
   * @param {Object} tools - Available tools for the agent
   * @returns {string} The prompt string
   */
  buildPrompt(context, tools) {
    const toolDescriptions = Object.keys(tools).map(name => `- ${name}`).join('\n');
    return `
You are an AI agent executing a task. You have access to the following tools:
${toolDescriptions}

Current task context:
${JSON.stringify(context, null, 2)}

Please respond with XML tool calls to perform the next step. Use the format:
<tool name="ToolName" action="action">
  <param1>value1</param1>
  <param2>value2</param2>
</tool>

If the task is complete, respond with an empty message (no tool calls).
`;
  }
}

module.exports = { AgentExecutor };
